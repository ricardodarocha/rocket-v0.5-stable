# Criando uma api com Rocket e Chat GPT3

Neste tutorial vamos criar uma api de produtos usando a biblioteca Rocket v0.5 que acaba de ser lan√ßada pela comunidade Rust ü¶Ä.
Aqui est√° um exemplo b√°sico de um aplicativo Rust Rocket v0.5. Este trecho criar√° um servidor web simples com uma rota /hello que responde com o texto "Hello, world!" quando acessado

```rust
#[macro_use] extern crate rocket;

#[get("/hello")]
fn hello() -> &'static str {
    "Hello, world!"
}

#[launch]
fn rocket() -> _ {
    rocket::build().mount("/", routes![hello])
}
```

Este c√≥digo usa o atributo #[get("/hello")] para declarar uma rota para solicita√ß√µes HTTP GET no caminho /hello. A fun√ß√£o hello retorna uma string est√°tica. A fun√ß√£o rocket constr√≥i e configura o aplicativo Rocket, montando a rota hello. O atributo #[launch] marca-o como o ponto de entrada para o aplicativo. Para executar isso, adicione rocket = "0.5" ao seu Cargo.toml em [depend√™ncias].

Para adicionar uma rota que lista produtos no seu aplicativo Rocket v0.5, voc√™ primeiro precisa definir uma estrutura para os produtos e uma fun√ß√£o que retorna uma lista desses produtos. Aqui est√° um exemplo simples

```rust
#[macro_use] extern crate rocket;
use rocket::serde::{Serialize, json::Json};

#[derive(Serialize)]
#[serde(crate = "rocket::serde")]
struct Product {
    id: i32,
    name: String,
    price: f32,
}

#[get("/products")]
fn list_products() -> Json<Vec<Product>> {
    let products = vec![
        Product { id: 1, name: "Produto A".to_string(), price: 10.99 },
        Product { id: 2, name: "Produto B".to_string(), price: 20.99 },
    ];

    Json(products)
}

#[launch]
fn rocket() -> _ {
    rocket::build().mount("/", routes![list_products])
}

```

Neste c√≥digo:

Product √© uma estrutura que representa um produto, com campos como id, name e price.
list_products √© uma fun√ß√£o que cria uma lista de produtos e a retorna como JSON.
A rota /products √© montada para servir a lista de produtos.
Veja que as depend√™ncias devem ser adicionadas ao seu toml:

[dependencies]
rocket = "0.5"
serde = { version = "1.0", features = ["derive"] }

Para adicionar uma rota que recupera um √∫nico produto pelo seu ID em um aplicativo Rocket v0.5, voc√™ precisar√° criar uma rota que aceita um par√¢metro na URL. Vou modificar o exemplo anterior para incluir essa nova rota:

```rust
#[macro_use] extern crate rocket;
use rocket::serde::{Serialize, json::Json};

#[derive(Serialize)]
#[serde(crate = "rocket::serde")]
struct Product {
    id: i32,
    name: String,
    price: f32,
}

#[get("/products")]
fn list_products() -> Json<Vec<Product>> {
    let products = vec![
        Product { id: 1, name: "Produto A".to_string(), price: 10.99 },
        Product { id: 2, name: "Produto B".to_string(), price: 20.99 },
    ];

    Json(products)
}

#[get("/product/<id>")]
fn get_product(id: i32) -> Option<Json<Product>> {
    let products = vec![
        Product { id: 1, name: "Produto A".to_string(), price: 10.99 },
        Product { id: 2, name: "Produto B".to_string(), price: 20.99 },
    ];

    products.into_iter().find(|p| p.id == id).map(Json)
}

#[launch]
fn rocket() -> _ {
    rocket::build().mount("/", routes![list_products, get_product])
}
```

Para adicionar uma rota que permite cadastrar um novo produto no seu aplicativo Rocket v0.5, voc√™ precisa criar uma rota que aceite dados POST.
Aqui a gente tamb√©m come√ßa a trabalhar com serde para manipular json, al√©m da camada serde disponibilizada pelo Rocket;


`serde = { version = "1.0", features = ["derive"] }`

voce tambem pode usar  o comando `cargo add serde --features derive` se preferir

```rust
#[macro_use] extern crate rocket;
use rocket::serde::{Serialize, Deserialize, json::Json};

#[derive(Serialize, Deserialize)]
#[serde(crate = "rocket::serde")]
struct Product {
    id: i32,
    name: String,
    price: f32,
}

#[get("/products")]
fn list_products() -> Json<Vec<Product>> {
    // Exemplo com produtos est√°ticos
    Json(vec![
        Product { id: 1, name: "Produto A".to_string(), price: 10.99 },
        Product { id: 2, name: "Produto B".to_string(), price: 20.99 },
    ])
}

#[get("/product/<id>")]
fn get_product(id: i32) -> Option<Json<Product>> {
    // Exemplo com produtos est√°ticos
    let products = vec![
        Product { id: 1, name: "Produto A".to_string(), price: 10.99 },
        Product { id: 2, name: "Produto B".to_string(), price: 20.99 },
    ];

    products.into_iter().find(|p| p.id == id).map(Json)
}

#[post("/product", format = "json", data = "<product>")]
fn new_product(product: Json<Product>) -> Json<Product> {
    // Aqui voc√™ pode adicionar l√≥gica para salvar o produto
    product
}

#[launch]
fn rocket() -> _ {
    rocket::build().mount("/", routes![list_products, get_product, new_product])
}
```

Product agora tamb√©m implementa Deserialize para permitir a desserializa√ß√£o dos dados JSON recebidos.
A fun√ß√£o new_product aceita dados JSON enviados numa requisi√ß√£o POST, desserializa-os para um Product, e ent√£o retorna o produto. Em um caso real, voc√™ adicionaria l√≥gica para salvar o produto em um banco de dados ou outro reposit√≥rio de dados.
Agora, voc√™ tem uma rota POST /product que aceita dados JSON para criar um novo produto. Note que neste exemplo, a funcionalidade de armazenamento persistente n√£o est√° implementada, ent√£o o produto recebido simplesmente √© retornado como resposta. Em um aplicativo real, voc√™ precisaria implementar a l√≥gica de persist√™ncia de dados.

Para adicionar uma rota que permite a atualiza√ß√£o parcial de um produto (conhecida como atualiza√ß√£o "patch") no seu aplicativo Rocket v0.5, voc√™ pode criar uma rota que aceite uma requisi√ß√£o PATCH. Essa rota dever√° receber o ID do produto e os campos a serem atualizados.

Vamos modificar o exemplo anterior para incluir essa nova rota. Para simplificar, vou simular a atualiza√ß√£o sem persist√™ncia em um banco de dados:

```rust
#[macro_use] extern crate rocket;
use rocket::serde::{Serialize, Deserialize, json::{Json, Value}};
use std::collections::HashMap;

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "rocket::serde")]
struct Product {
    id: i32,
    name: String,
    price: f32,
}

// Simulando um banco de dados com um HashMap
type Db = HashMap<i32, Product>;

#[patch("/product/<id>", format = "json", data = "<product_patch>")]
fn update_product(id: i32, product_patch: Json<Value>, db: &rocket::State<Db>) -> Option<Json<Product>> {
    let mut db = db.lock().unwrap();
    if let Some(product) = db.get_mut(&id) {
        if let Some(name) = product_patch.get("name").and_then(Value::as_str) {
            product.name = name.to_string();
        }
        if let Some(price) = product_patch.get("price").and_then(Value::as_f64) {
            product.price = price as f32;
        }
        return Some(Json(product.clone()));
    }
    None
}

#[launch]
fn rocket() -> _ {
    let db: Db = vec![
        (1, Product { id: 1, name: "Produto A".to_string(), price: 10.99 }),
        (2, Product { id: 2, name: "Produto B".to_string(), price: 20.99 }),
    ].into_iter().collect();

    rocket::build()
        .manage(Mutex::new(db))
        .mount("/", routes![update_product])
}

```

A fun√ß√£o update_product recebe o ID do produto e um JSON com os campos a serem atualizados.
Usamos um HashMap como um banco de dados simulado para armazenar produtos. Em um aplicativo real, voc√™ usaria um banco de dados de verdade.
O JSON recebido √© usado para atualizar os campos name e price do produto, se eles estiverem presentes na requisi√ß√£o.
A rota PATCH /product/<id> agora permite atualizar parcialmente um produto existente.

Para integrar um banco de dados SQLite usando SQLx em um aplicativo Rocket v0.5, voc√™ precisa seguir alguns passos. Vamos come√ßar adicionando as depend√™ncias necess√°rias no seu Cargo.toml:

``` 
sqlx = { version = "0.7.2", features = ["runtime-tokio-rustls", "sqlite"] }
tokio = { version = "1", features = ["full"] }
```
```rust
#[macro_use] extern crate rocket;
use rocket::serde::{Serialize, Deserialize, json::Json};
use sqlx::{SqlitePool, sqlite::SqlitePoolOptions};

#[derive(Serialize, Deserialize)]
#[serde(crate = "rocket::serde")]
struct Product {
    id: i32,
    name: String,
    price: f32,
}

#[get("/products")]
async fn list_products(db: &rocket::State<SqlitePool>) -> Result<Json<Vec<Product>>, sqlx::Error> {
    let products = sqlx::query_as!(Product, "SELECT * FROM products")
        .fetch_all(db.inner()).await?;

    Ok(Json(products))
}

// Outras rotas aqui...

#[launch]
async fn rocket() -> _ {
    let db_pool = SqlitePoolOptions::new()
        .connect("sqlite:meu_banco.db").await
        .expect("Erro ao conectar ao banco de dados");

    // Inicializando o banco de dados (Opcional)
    sqlx::query("CREATE TABLE IF NOT EXISTS products (id INTEGER PRIMARY KEY, name TEXT NOT NULL, price REAL NOT NULL, tipo VARCHAR(10))")
        .execute(&db_pool).await
        .expect("Erro ao criar a tabela prod");

    rocket::build().manage(db_pool).mount("/", routes![list_products])
}
```

Para iniciar o banco de dados adicione uma √∫ltima crate 

```
cargo install sqlx-cli
cargo sqlx prepare
```

Criando e Manipulando Dados:

Para criar, atualizar e manipular dados, voc√™ usaria comandos SQLx semelhantes dentro das fun√ß√µes correspondentes a cada rota. Por exemplo, para adicionar um produto, voc√™ pode usar `sqlx::query!("INSERT INTO products (name, price) VALUES (?, ?)", new_product.name, new_product.price).execute(&*db).await.`

Certifique-se de adaptar cada rota para operar de forma ass√≠ncrona e interagir com o banco de dados.
Trate os erros adequadamente em suas rotas.
Voc√™ pode querer adicionar l√≥gica para iniciar e gerenciar transa√ß√µes onde for necess√°rio.
Este exemplo estabelece uma base para um aplicativo Rocket com SQLx e SQLite, incluindo opera√ß√µes CRUD b√°sicas. Voc√™ precisar√° expandir e modificar este c√≥digo para atender √†s necessidades espec√≠ficas do seu aplicativo e garantir que todas as opera√ß√µes do banco de dados sejam realizadas corretamente.

Por fim n√≥s separamos  em m√≥dulos para deixar tudo organizado

1. Estrutura de Diret√≥rios
Suponha a seguinte estrutura de diret√≥rios:

lua
Copy code
src/
|-- db/
|   |-- mod.rs
|-- routes/
|   |-- mod.rs
|-- main.rs

2. M√≥dulo de Banco de Dados (db)
No arquivo src/db/mod.rs, voc√™ configurar√° o pool de conex√£o e as fun√ß√µes relacionadas ao banco de dados.

```rust
// src/db/mod.rs
use sqlx::{SqlitePool, Pool, Sqlite};
use rocket::fairing::AdHoc;

pub async fn init_db_pool(database_url: &str) -> Result<Pool<Sqlite>, sqlx::Error> {
    SqlitePool::connect(database_url).await
}

pub fn stage() -> AdHoc {
    AdHoc::on_ignite("Database Stage", |rocket| async {
        let database_url = rocket.figment().extract_inner::<String>("database.url")
            .unwrap_or_else(|_| "sqlite:meu_banco.db".to_string());

        let db_pool = match init_db_pool(&database_url).await {
            Ok(pool) => pool,
            Err(e) => {
                panic!("Database connection failed: {}", e);
            }
        };

        rocket.manage(db_pool)
    })
}

```

3. M√≥dulo de Rotas (routes)
No arquivo src/routes/mod.rs, voc√™ definir√° as rotas do seu aplicativo.

```rust
// src/routes/mod.rs
use rocket::serde::{json::Json, Serialize, Deserialize};
use sqlx::SqlitePool;

#[derive(Serialize, Deserialize)]
#[serde(crate = "rocket::serde")]
pub struct Product {
    id: i32,
    name: String,
    price: f32,
}

#[get("/products")]
pub async fn list_products(db: &rocket::State<SqlitePool>) -> Result<Json<Vec<Product>>, sqlx::Error> {
    let products = sqlx::query_as!(Product, "SELECT * FROM products")
        .fetch_all(db.inner()).await?;

    Ok(Json(products))
}

// Outras rotas aqui...
```

```rust
// src/main.rs
#[macro_use] extern crate rocket;

mod db;
mod routes;

#[rocket::main]
async fn main() {
    let _ = rocket::build()
        .attach(db::stage())
        .mount("/", routes![routes::list_products])
        .launch()
        .await;
}

```
A fun√ß√£o db::init_db_pool inicia o pool de conex√µes do SQLite, e db::stage √© um 'stage' Rocket para inicializar e gerenciar a conex√£o com o banco de dados. As rotas s√£o definidas no m√≥dulo routes.
No main.rs, o aplicativo √© configurado e iniciado com os m√≥dulos db e routes.
Certifique-se de que as depend√™ncias corretas est√£o no seu Cargo.toml e ajuste o c√≥digo conforme necess√°rio para atender √†s necessidades espec√≠ficas do seu aplicativo. O comando final para compilar, procurando por erros e recebendo sugest√µes de ajuste

cargo check
cargo clippy
cargo build --release
cargo run --release
